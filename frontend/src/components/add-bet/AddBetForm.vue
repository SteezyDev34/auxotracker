<template>
  <div class="container mx-auto p-6 max-w-4xl">
    <h1 class="text-2xl font-bold mb-6">
      {{ events.length > 1 ? 'Ajouter un pari combiné' : 'Ajouter un pari simple' }}
    </h1>
    

    <form @submit.prevent="submitForm" class="space-y-4 mb-4">
      <!-- Date du pari -->
      <DatePickerField 
        v-model="formData.bet_date" 
        fieldId="bet_date"
        placeholder="Date du pari"
        :required="true"
        dateFormat="dd/mm/yy" 
        :showIcon="true" 
        fieldClass="w-full"
        :error="!!errors.bet_date"
        :errorMessage="errors.bet_date"
      />

      <!-- Cards Événements -->
      <div v-for="(eventData, eventIndex) in eventCards" :key="eventData.id" class="border-surface-200 dark:border-surface-600 border rounded-lg p-4 mb-4">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-lg font-semibold">Événement {{ eventIndex + 1 }}</h3>
          <Button 
            v-if="eventCards.length > 1"
            icon="pi pi-times" 
            class="p-button-text p-button-sm text-red-500"
            @click="removeEventCard(eventIndex)"
            aria-label="Supprimer cet événement"
          />
        </div>
        
        <!-- Sport -->
        <div class="flex flex-col gap-2 mb-4">
          <label :for="`sport_${eventIndex}`" class="font-medium text-sm">Sport *</label>
          <AutoComplete 
          :ref="(el) => { if (el) sportAutoCompleteRefs[eventIndex] = el }"
          :id="`sport_${eventIndex}`" 
          v-model="eventData.selectedSport" 
          :suggestions="eventData.sportSearchResults || []" 
          @complete="(event) => searchSports(event, eventIndex)"
          @item-select="(event) => onSportSelect(event, eventIndex)"
          @click="() => onSportDropdownShow(eventIndex)"
          optionLabel="name"
          :placeholder="eventData.selectedSport && eventData.selectedSport.length > 0 ? '' : 'Sport'"
          class="w-full max-w-full select-custom"
          :class="{ 'p-invalid': errors[`sport_id_${eventIndex}`] }"
          :loading="eventData.sportLoading"
          panelClass="select-panel-custom"
          @show="() => onSportDropdownShow(eventIndex)"
          @focus="() => onSportDropdownShow(eventIndex)"
          :minLength="0"
          dropdown
          dropdownMode="blank"
          multiple
          display="chip"
          aria-label="Rechercher et sélectionner un sport"
          role="combobox"
          aria-expanded="false"
          aria-autocomplete="list"
        >
          <!-- Template pour afficher le sport sélectionné avec son icône -->
          <template #chip="slotProps">
            <div class="flex items-center gap-2">
              <!-- Icône du sport sélectionné -->
              <img
                v-if="slotProps.value && slotProps.value.slug"
                :src="`${apiBaseUrl}/storage/sport_icons/${slotProps.value.slug}${isDarkTheme ? '-dark' : ''}.svg`"
                :alt="slotProps.value.name"
                class="w-4 h-4 rounded object-cover flex-shrink-0"
                @error="$event.target.style.display='none'"
              />
              <!-- Nom du sport sélectionné -->
              <span>{{ slotProps.value ? slotProps.value.name : '' }}</span>
            </div>
          </template>
            
            <!-- Template pour les options du dropdown -->
            <template #option="slotProps">
              <div class="flex items-center gap-2 truncate max-w-full" :title="slotProps.option.name">
                <!-- Icône du sport -->
                <img
                  v-if="slotProps.option.img"
                  :src="`${apiBaseUrl}/storage/sport_icons/${slotProps.option.slug}${isDarkTheme ? '-dark' : ''}.svg`"
                  :alt="slotProps.option.name"
                  class="w-5 h-5 object-contain"
                  @error="$event.target.style.display='none'"
                />
                <div 
                  v-else
                  class="w-5 h-5 bg-gray-300 rounded-full flex items-center justify-center text-xs text-gray-600 flex-shrink-0"
                >
                  {{ slotProps.option.name ? slotProps.option.name.charAt(0).toUpperCase() : '?' }}
                </div>
                <!-- Nom du sport -->
                <span class="truncate">{{ slotProps.option.name }}</span>
              </div>
            </template>
          </AutoComplete>
          <small v-if="errors[`sport_id_${eventIndex}`]" class="text-red-500 block mt-1">{{ errors[`sport_id_${eventIndex}`] }}</small>
        </div>

        <!-- Champs conditionnels selon le sport -->
        <div v-if="eventData.sport_id" class="space-y-4 mb-4">
          <!-- Pays -->
          <div class="flex flex-col gap-2">
            <div class="relative">
              <AutoComplete 
                :ref="(el) => { if (el) countryAutoCompleteRefs[eventIndex] = el }"
                :id="`country_${eventIndex}`" 
                v-model="eventData.selectedCountry" 
                :suggestions="eventData.countryFilteredResults || []" 
                @complete="(event) => searchCountries(event, eventIndex)"
                @focus="() => onCountryDropdownShow(eventIndex)"
                @click="() => onCountryDropdownShow(eventIndex)"
                @item-select="(event) => onCountrySelect(event, eventIndex)"
                optionLabel="name"
                :placeholder="eventData.selectedCountry && eventData.selectedCountry.length > 0 ? '' : 'Pays'"
                class="w-full max-w-full select-custom"
                :class="{ 'p-invalid': errors[`country_id_${eventIndex}`] }"
                :loading="eventData.countryLoading"
                :disabled="!eventData.sport_id"
                :minLength="0"
                dropdown
                dropdownMode="blank"
                multiple
                display="chip"
                aria-label="Rechercher et sélectionner un pays"
                role="combobox"
                aria-expanded="false"
                aria-autocomplete="list"
            >
                <!-- Template pour afficher le pays sélectionné avec son drapeau -->
                <template #chip="slotProps">
                  <div class="flex items-center gap-2">
                    <!-- Drapeau du pays sélectionné -->
                    <img 
                      v-if="slotProps.value && slotProps.value.id"
                      :src="`${apiBaseUrl}/storage/country_flags/${slotProps.value.id}.png`" 
                      :alt="slotProps.value.name"
                      class="w-4 h-4 rounded object-cover flex-shrink-0" 
                      @error="$event.target.style.display='none'"
                    />
                    <!-- Nom du pays sélectionné -->
                    <span>{{ slotProps.value ? slotProps.value.name : '' }}</span>
                  </div>
                </template>
                
                <!-- Template pour les options du dropdown -->
                <template #option="slotProps">
                  <div class="flex items-center gap-2 truncate max-w-full" :title="slotProps.option.name">
                    <!-- Drapeau du pays -->
                    <img 
                      v-if="slotProps.option.id"
                      :src="`${apiBaseUrl}/storage/country_flags/${slotProps.option.id}.png`" 
                      :alt="slotProps.option.name"
                      class="w-4 h-4 rounded object-cover flex-shrink-0" 
                      @error="$event.target.style.display='none'"
                    />
                    <!-- Nom du pays -->
                    <span class="truncate">{{ slotProps.option.name }}</span>
                  </div>
                </template>

              </AutoComplete>
            </div>
            <small v-if="errors.country_id" class="text-red-500 block mt-1">{{ errors.country_id }}</small>
          </div>

          <!-- Ligue -->
          <div class="flex flex-col gap-2">
            <div class="relative">
              <AutoComplete 
                :ref="(el) => { if (el) leagueAutoCompleteRefs[eventIndex] = el }"
                :id="`league-${eventIndex}`" 
                v-model="eventData.selectedLeague" 
                :suggestions="eventData.leagueSearchResults" 
                @complete="(event) => searchLeagues(event, eventIndex)"
                @focus="() => onLeagueDropdownShow(eventIndex)"
                @click="() => onLeagueDropdownShow(eventIndex)"
                @item-select="(event) => onLeagueSelect(event, eventIndex)"
                optionLabel="name"
                :placeholder="eventData.selectedLeague && eventData.selectedLeague.length > 0 ? '' : 'Ligue'"
                class="w-full max-w-full select-custom"
                :class="{ 'p-invalid': errors[`league-${eventIndex}`] }"
                :loading="eventData.leagueLoading"
                :disabled="!eventData.sport_id"
                :minLength="0"
                dropdown
                dropdownMode="blank"
                multiple
                display="chip"
                aria-label="Rechercher et sélectionner une ligue"
              >
                <!-- Template pour afficher la ligue sélectionnée avec son logo -->
                 <template #chip="slotProps">
                   <div class="flex items-center gap-2">
                     
                     <!-- Logo de la ligue -->
                     <img 
                       v-if="slotProps.value.id"
                       :src="`${apiBaseUrl}/storage/league_logos/${slotProps.value.id}${isDarkTheme ? '-dark' : ''}.png`" 
                       :alt="slotProps.value.name"
                       class="w-4 h-4 rounded object-cover flex-shrink-0" 
                       @error="$event.target.style.display='none'"
                     />
                     <!-- Nom de la ligue -->
                     <span>{{ slotProps.value ? slotProps.value.name : '' }}</span>
                   </div>
                 </template>
                <template #option="slotProps">
                  <div class="flex items-center gap-2 truncate max-w-full" :title="slotProps.option.name">
                    <!-- Drapeau du pays -->
                    <img 
                       v-if="slotProps.option.country_id"
                       :src="`${apiBaseUrl}/storage/country_flags/${slotProps.option.country_id}.png`" 
                       :alt="slotProps.option.country?.name || 'Pays'"
                       class="w-4 h-4 rounded object-cover flex-shrink-0" 
                       @error="$event.target.style.display='none'"
                     />
                    <!-- Logo de la ligue -->
                    <img 
                      v-if="slotProps.option.img"
                      :src="`${apiBaseUrl}/storage/league_logos/${slotProps.option.id}${isDarkTheme ? '-dark' : ''}.png`" 
                      :alt="slotProps.option.name"
                      class="w-4 h-4 rounded object-cover flex-shrink-0" 
                      @error="$event.target.style.display='none'"
                    />
                    <!-- Nom de la ligue -->
                    <span class="truncate">{{ slotProps.option.name }}</span>
                  </div>
                </template>
                
                <template #footer v-if="leagueHasMore">
                  <div class="flex justify-center items-center p-2" v-if="leagueLoading">
                    <i class="pi pi-spin pi-spinner"></i>
                  </div>
                  <div class="text-center p-2 text-sm text-gray-500" v-else>
                    Faites défiler pour charger plus de résultats
                  </div>
                </template>
              </AutoComplete>
            </div>
            <small v-if="errors[`league-${eventIndex}`]" class="text-red-500 block mt-1">{{ errors[`league-${eventIndex}`] }}</small>
          </div>

          <!-- Équipes -->
          <div class="space-y-4">
            <!-- Équipe 1 -->
            <div class="flex flex-col gap-2">
              <div class="relative">
                <AutoComplete 
                  :id="`team1-${eventIndex}`" 
                  v-model="eventData.selectedTeam1" 
                  :suggestions="eventData.team1SearchResults" 
                  @complete="(event) => searchTeam1(event, eventIndex)"
                  @item-select="(event) => onTeam1Select(event, eventIndex)"
                  @click="() => onTeam1DropdownShow(eventIndex)"
                  optionLabel="name"
                  :placeholder="eventData.selectedTeam1 && eventData.selectedTeam1.length > 0 ? '' : 'Équipe 1'"
                  class="w-full max-w-full select-custom"
                  :class="{ 'p-invalid': errors[`team1-${eventIndex}`] }"
                  :loading="eventData.team1Loading"
                  :disabled="!eventData.sport_id"
                  panelClass="select-panel-custom"
                  @show="() => onTeam1DropdownShow(eventIndex)"
                  @focus="() => searchTeam1({ query: '' }, eventIndex)"
                  :minLength="0"
                  dropdown
                  dropdownMode="blank"
                  multiple
                  display="chip"
                  aria-label="Rechercher et sélectionner l'équipe 1"
                  role="combobox"
                  aria-expanded="false"
                  aria-autocomplete="list"
                >
                  <!-- Template pour afficher l'équipe 1 sélectionnée avec son logo -->
                   <template #chip="slotProps">
                     <div class="flex items-center gap-2">
                       <!-- Logo de l'équipe -->
                       <img 
                         v-if="slotProps.value.id"
                         :src="`${apiBaseUrl}/storage/team_logos/${slotProps.value.id}.png`" 
                         :alt="slotProps.value.name"
                         class="w-4 h-4 rounded object-cover flex-shrink-0" 
                         @error="$event.target.style.display='none'"
                       />
                       <!-- Nom de l'équipe -->
                       <span>{{ slotProps.value ? slotProps.value.name : '' }}</span>
                     </div>
                   </template>
                  <template #option="slotProps">
                    <div class="flex items-center gap-2 truncate max-w-full" :title="slotProps.option.name">
                      <!-- Logo de l'équipe -->
                      <img 
                        v-if="slotProps.option.img"
                        :src="`${apiBaseUrl}/storage/${slotProps.option.img}`" 
                        :alt="slotProps.option.name"
                        class="w-4 h-4 rounded object-cover flex-shrink-0" 
                        @error="$event.target.style.display='none'"
                      />
                      <!-- Nom de l'équipe -->
                      <span class="truncate">{{ slotProps.option.name }}</span>
                      <span v-if="slotProps.option.league_name" class="text-sm text-gray-500 ml-2">
                        ({{ slotProps.option.league_name }})
                      </span>
                    </div>
                  </template>
                  
                  <template #footer v-if="team1HasMore">
                    <div class="flex justify-center items-center p-2" v-if="team1Loading">
                      <i class="pi pi-spin pi-spinner"></i>
                    </div>
                    <div class="text-center p-2 text-sm text-gray-500" v-else>
                      Faites défiler pour charger plus de résultats
                    </div>
                  </template>
                </AutoComplete>
              </div>
              <small v-if="errors[`team1-${eventIndex}`]" class="text-red-500 block mt-1">{{ errors[`team1-${eventIndex}`] }}</small>
            </div>
            
            <!-- Équipe 2 -->
            <div class="flex flex-col gap-2">
              <div class="relative">
                  <AutoComplete 
                    :id="`team2-${eventIndex}`" 
                    v-model="eventData.selectedTeam2" 
                    :suggestions="eventData.team2SearchResults" 
                    @complete="(event) => searchTeam2(event, eventIndex)"
                    @item-select="(event) => onTeam2Select(event, eventIndex)"
                    @click="() => onTeam2DropdownShow(eventIndex)"
                    optionLabel="name"
                    :placeholder="eventData.selectedTeam2 && eventData.selectedTeam2.length > 0 ? '' : 'Équipe 2'"
                    class="w-full max-w-full select-custom"
                    :class="{ 'p-invalid': errors[`team2-${eventIndex}`] }"
                    :loading="eventData.team2Loading"
                    :disabled="!eventData.sport_id"
                    panelClass="select-panel-custom"
                    @show="() => onTeam2DropdownShow(eventIndex)"
                    @focus="() => searchTeam2({ query: '' }, eventIndex)"
                    :minLength="0"
                    dropdown
                    dropdownMode="blank"
                    multiple
                    display="chip"
                    aria-label="Rechercher et sélectionner l'équipe 2"
                    role="combobox"
                    aria-expanded="false"
                    aria-autocomplete="list"
                  >
                    <!-- Template pour afficher l'équipe 2 sélectionnée avec son logo -->
                     <template #chip="slotProps">
                       <div class="flex items-center gap-2">
                         <!-- Logo de l'équipe -->
                         <img 
                           v-if="slotProps.value.id"
                           :src="`${apiBaseUrl}/storage/team_logos/${slotProps.value.id}.png`" 
                           :alt="slotProps.value.name"
                           class="w-4 h-4 rounded object-cover flex-shrink-0" 
                           @error="$event.target.style.display='none'"
                         />
                         <!-- Nom de l'équipe -->
                         <span>{{ slotProps.value ? slotProps.value.name : '' }}</span>
                       </div>
                     </template>
                    <template #option="slotProps">
                      <div class="flex items-center gap-2 truncate max-w-full" :title="slotProps.option.name">
                        <!-- Logo de l'équipe -->
                        <img 
                          v-if="slotProps.option.img"
                          :src="`${apiBaseUrl}/storage/${slotProps.option.img}`" 
                          :alt="slotProps.option.name"
                          class="w-4 h-4 rounded object-cover flex-shrink-0" 
                          @error="$event.target.style.display='none'"
                        />
                        <!-- Nom de l'équipe -->
                        <span class="truncate">{{ slotProps.option.name }}</span>
                        <span v-if="slotProps.option.league_name" class="text-sm text-gray-500 ml-2">
                          ({{ slotProps.option.league_name }})
                        </span>
                      </div>
                    </template>
                    
                    <template #footer v-if="team2HasMore">
                      <div class="flex justify-center items-center p-2" v-if="team2Loading">
                        <i class="pi pi-spin pi-spinner"></i>
                      </div>
                      <div class="text-center p-2 text-sm text-gray-500" v-else>
                        Faites défiler pour charger plus de résultats
                      </div>
                    </template>
                  </AutoComplete>
                </div>
                <small v-if="errors[`team2-${eventIndex}`]" class="text-red-500 block mt-1">{{ errors[`team2-${eventIndex}`] }}</small>
              </div>
            </div>
        </div>
        
        <!-- Type de pari -->
        <div class="flex flex-col gap-2 mb-4">
          <label :for="`bet_type_${eventIndex}`" class="font-medium text-sm">Type de pari</label>
          <Select 
            :id="`bet_type_${eventIndex}`" 
            v-model="eventData.bet_type" 
            :options="getFilteredBetTypesForEvent(eventData)" 
            optionLabel="label" 
            optionValue="value"
            @click="() => onBetTypeDropdownShow(eventIndex)"
            placeholder="Sélectionner un type de pari"
            class="w-full select-custom"
            :class="{ 'p-invalid': errors[`bet_type-${eventIndex}`] }"
            :disabled="!eventData.sport_id"
            dropdown
            dropdownMode="blank"
          />
          <small v-if="errors[`bet_type-${eventIndex}`]" class="text-red-500 block mt-1">{{ errors[`bet_type-${eventIndex}`] }}</small>
        </div>
        
        <!-- Description de l'événement -->
        <div class="flex flex-col gap-2 mb-4">
          <InputText 
            :id="`event_description_${eventIndex}`" 
            v-model="eventData.description" 
            placeholder="Description de l'événement *"
            class="w-full"
            :class="{ 'p-invalid': errors[`event_description-${eventIndex}`] }"
          />
          <small v-if="errors[`event_description-${eventIndex}`]" class="text-red-500 block mt-1">{{ errors[`event_description-${eventIndex}`] }}</small>
        </div>

            <!-- Champs spécifiques à l'événement pour les paris combinés -->
            <div v-if="events.length > 0" class="space-y-4">
              <!-- Résultat de l'événement -->
              <div class="flex flex-col gap-2">
                <Select 
                  :id="`event_result_${eventIndex}`" 
                  v-model="eventData.result" 
                  :options="resultOptions" 
                  optionLabel="label" 
                  optionValue="value"
                  placeholder="Résultat de l'événement *"
                  class="w-full select-custom"
                  :class="{ 'p-invalid': errors[`event_result-${eventIndex}`] }"
                  panelClass="select-panel-custom"
                  aria-label="Sélectionner le résultat de l'événement"
                />
                <small v-if="errors[`event_result-${eventIndex}`]" class="text-red-500 block mt-1">{{ errors[`event_result-${eventIndex}`] }}</small>
              </div>

              <!-- Cote de l'événement -->
              <div class="flex flex-col gap-2">
                <InputText 
                  :id="`event_odds_${eventIndex}`" 
                  :ref="`eventOddsInput_${eventIndex}`"
                  v-model="eventData.odds" 
                  placeholder="Cote de l'événement *"
                  class="w-full"
                  :class="{ 'p-invalid': errors[`event_odds-${eventIndex}`] }"
                  type="text"
                  @input="(e) => handleEventOddsInput(e, eventIndex)"
                  @keypress="handleEventOddsKeypress"
                />
                <small v-if="errors[`event_odds-${eventIndex}`]" class="text-red-500 block mt-1">{{ errors[`event_odds-${eventIndex}`] }}</small>
              </div>
            </div>
          </div>
          <!-- Bouton Ajouter un pari combiné -->
          <div class="flex justify-center mt-4 mb-4">
            <Button 
              type="button" 
              label="Ajouter un pari combiné" 
              icon="pi pi-plus" 
              class="p-button-outlined p-button-sm"
              @click="addEventCard"
            />
          </div>
    </form>
      <!-- Liste des événements ajoutés -->
      <div v-if="events.length > 0" class="border rounded-lg p-4 bg-blue-50">
        <h3 class="text-lg font-semibold mb-4 text-blue-800">Événements du pari combiné ({{ events.length }})</h3>
        
        <div class="space-y-3">
          <div v-for="(event, index) in events" :key="event.id" class="bg-white p-3 rounded border">
            <div class="flex justify-between items-start">
              <div class="flex-1">
                <div class="text-sm font-medium text-gray-800 mb-1">
                  Événement {{ index + 1 }}
                </div>
                <div class="text-sm text-gray-600 mb-2">
                  {{ event.team1?.name }} vs {{ event.team2?.name }}
                </div>
                <div class="text-xs text-gray-500 mb-1">
                  {{ event.league?.name }}
                </div>
                <div class="text-sm text-gray-700 mb-1">
                  {{ event.description }}
                </div>
                <div class="flex gap-4 text-xs">
                  <span v-if="event.odds" class="text-green-600 font-medium">
                    Cote: {{ event.odds }}
                  </span>
                  <span v-if="event.result" class="font-medium" :class="getResultClass(event.result)">
                    Résultat: {{ getResultLabel(event.result) }}
                  </span>
                </div>
              </div>
              <Button 
                icon="pi pi-times" 
                class="p-button-text p-button-sm text-red-500"
                @click="removeEvent(index)"
                aria-label="Supprimer cet événement"
              />
            </div>
          </div>
        </div>
      </div>
      <!-- Cote, Mise et Type -->
      <div class="grid grid-cols-3 sm:grid-cols-4 gap-1 overflow-hidden">
        <!-- Cote -->
        <div class="flex flex-col justify-center min-w-0 w-full">
          <div class="w-full">
            <InputText 
              id="global_odds" 
              v-model="formData.global_odds" 
              type="text"
              placeholder="Cote"
              class="w-full text-xs"
              :class="{ 'p-invalid': errors.global_odds }"
              @input="handleOddsInput"
              @keypress="handleOddsKeypress"
            />
          </div>
          <small v-if="errors.global_odds" class="text-red-500 text-xs truncate">{{ errors.global_odds }}</small>
        </div>
        
        <!-- Mise -->
        <div class="flex flex-col justify-center min-w-0 w-full">
          <div class="w-full">
            <InputText 
              id="stake" 
              v-model="formData.stake" 
              type="text"
              :placeholder="betTypeValue === 'currency' ? 'Mise en €' : betTypeValue === 'percentage' ? 'Mise en %' : 'Mise'"
              class="w-full text-xs"
              :class="{ 'p-invalid': errors.stake }"
              @input="handleStakeInput"
              @keypress="handleStakeKeypress"
            />
          </div>
          <small v-if="errors.stake" class="text-red-500 text-xs truncate">{{ errors.stake }}</small>
        </div>

        <!-- Type de mise -->
        <div class="flex flex-col justify-center min-w-0 w-full">
          <div class="w-full flex items-center">
            <SelectButton 
              v-model="betTypeValue" 
              :options="betTypeOptions" 
              optionLabel="symbol" 
              optionValue="value"
              class="h-8 text-xs w-full"
            />
          </div>
        </div>

       
      </div>
      <!-- Section détaillée du gain potentiel (mode pourcentage uniquement) -->
      <div v-if="betTypeValue === 'percentage'" class="flex flex-col gap-2 mb-4 mt-4">
        <div class="p-4 bg-gray-50 rounded border">
          <h4 class="text-sm font-semibold text-gray-800 mb-3">Détails du gain potentiel</h4>
          <!-- Capital actuel -->
          <div class="flex justify-between items-center mb-2">
            <span class="text-sm text-gray-600">Capital actuel :</span>
            <span class="text-sm font-medium">
              <i v-if="capitalLoading" class="pi pi-spin pi-spinner text-xs"></i>
              <span v-else>{{ currentCapital.toFixed(2) }} €</span>
            </span>
          </div>
          
          <!-- Mise calculée -->
          <div v-if="calculatedStake > 0" class="flex justify-between items-center mb-2">
            <span class="text-sm text-gray-600">Mise calculée ({{ formData.stake }}%) :</span>
            <span class="text-sm font-medium text-blue-600">{{ calculatedStake.toFixed(2) }} €</span>
          </div>
          
          <!-- Cote -->
          <div v-if="formData.global_odds" class="flex justify-between items-center mb-2">
            <span class="text-sm text-gray-600">Cote :</span>
            <span class="text-sm font-medium">{{ parseFloat(formData.global_odds).toFixed(2) }}</span>
          </div>
          
          <!-- Gain potentiel -->
          <div class="flex justify-between items-center pt-2 border-t border-gray-200">
            <span class="text-sm font-semibold text-gray-800">Gain potentiel :</span>
            <span class="text-lg font-bold text-green-600">{{ potentialWin.toFixed(2) }} €</span>
          </div>
        </div>
      </div>
      <!-- Gain potentiel simple (mode devise uniquement) -->
      <div v-if="betTypeValue === 'currency'" class="flex flex-col gap-2 mt-4 mb-4">
        <div class="p-3 bg-gray-50 rounded border text-lg font-semibold text-green-600 text-center">
          Gain potentiel : {{ potentialWin.toFixed(2) }} €
        </div>
      </div>
      <!-- Résultat (optionnel) -->
      <div class="flex flex-col sm:flex-row sm:items-center gap-2">
        <div class="flex-1">
          <Select 
            id="result" 
            v-model="formData.result" 
            :options="resultOptions" 
            optionLabel="label" 
            optionValue="value" 
            placeholder="Sélectionner un résultat"
            class="w-full"
          />
        </div>
      </div>
    <div class="flex justify-end gap-2 mt-4">
      <Button 
        label="Annuler" 
        icon="pi pi-times" 
        @click="closeDialog" 
        class="p-button-text"
      />
      <Button 
        label="Ajouter le pari" 
        icon="pi pi-check" 
        @click="submitForm" 
        :loading="loading"
        :disabled="!isFormValid"
      />
    </div>
  </div>
</template>
<script setup>
import { ref, reactive, computed, onMounted, nextTick, watch } from 'vue';
// Dialog import supprimé car ce n'est plus un Dialog
import Button from 'primevue/button';
import InputText from 'primevue/inputtext';
import InputNumber from 'primevue/inputnumber';
import Select from 'primevue/select';
import SelectButton from 'primevue/selectbutton';
import AutoComplete from 'primevue/autocomplete';
import DatePickerField from '@/components/DatePickerField.vue';
import { BetService } from '@/service/BetService';
import { SportService } from '@/service/SportService';
import { CountryService } from '@/service/CountryService';
import { useToast } from 'primevue/usetoast';
import { useLayout } from '@/layout/composables/layout';
import { useBetResults } from '@/composables/useBetResults';
import { useBetTypes } from '@/composables/useBetTypes';
// Props
// Props supprimés car ce n'est plus un Dialog
// Emits
const emit = defineEmits(['bet-created']);
// Composables
const toast = useToast();
const { isDarkTheme: layoutDarkTheme } = useLayout(); // Indique si le thème sombre est actif
const { resultOptions, resultValues, getResultLabel, getResultClass } = useBetResults(); // Options de résultats globales
const { getBetTypesForSport, betTypeOptions: allBetTypeOptions } = useBetTypes(); // Gestion des types de paris
// Computed local pour s'assurer de la réactivité
const isDarkTheme = computed(() => layoutDarkTheme.value);
// Variables réactives
const loading = ref(false);
const availableSports = ref([]); // Liste des sports disponibles
const sportsLoading = ref(false); // État de chargement des sports
const countries = ref([]);
const allCountries = ref([]);
const errors = ref({});
// Cache pour les pays par sport
const countriesBySportCache = ref(new Map());
const eventOddsInput = ref(null);
const availableLeagues = ref([]);
const availableTeams = ref([]);
const apiBaseUrl = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000';
// Variables pour la recherche de pays
const countrySearchQuery = ref('');
const countrySearchResults = ref([]);
const countryLoading = ref(false);
const countryCurrentPage = ref(1);
const countryHasMore = ref(false);
const selectedCountry = ref([]);
// Variables pour la recherche de ligues
const leagueSearchQuery = ref('');
const leagueSearchResults = ref([]);
const leagueLoading = ref(false);
const leagueCurrentPage = ref(1);
const leagueHasMore = ref(false);
const selectedLeague = ref([]);
// Variables pour la recherche d'équipes 1
const team1SearchQuery = ref('');
const team1SearchResults = ref([]);
const team1Loading = ref(false);
const team1CurrentPage = ref(1);
const team1HasMore = ref(false);
const selectedTeam1 = ref([]);
// Variables pour la recherche d'équipes 2
const team2SearchQuery = ref('');
const team2SearchResults = ref([]);
const team2Loading = ref(false);
const team2CurrentPage = ref(1);
const team2HasMore = ref(false);
const selectedTeam2 = ref([]);
// Variables pour la recherche de sports
const sportSearchQuery = ref('');
const sportSearchResults = ref([]);
const sportLoading = ref(false);
const selectedSport = ref([]);

// Références pour les composants AutoComplete
const sportAutoCompleteRefs = ref({});
const countryAutoCompleteRefs = ref({});
const leagueAutoCompleteRefs = ref({}); // Initialisation comme un objet simple
const team1AutoCompleteRefs = ref({});
const team2AutoCompleteRefs = ref({});

// Variables pour le type de mise
const betTypeValue = ref('currency');
const betTypeOptions = ref([
  { symbol: '€', value: 'currency' },
  { symbol: '%', value: 'percentage' }
]);

// Variables pour le capital actuel
const currentCapital = ref(0);
const calculatedStake = ref(0);
const capitalLoading = ref(false);

// Variables pour les cards d'événements multiples
const eventCards = ref([
  {
    id: 1,
    sport_id: null,
    country_id: null,
    league: null,
    team1: null,
    team2: null,
    bet_type: null,
    description: '',
    result: null,
    odds: null,
    selectedSport: [],
    selectedCountry: [],
    selectedLeague: [],
    selectedTeam1: [],
    selectedTeam2: [],
    sportSearchResults: [],
    sportLoading: false,
    countryFilteredResults: [],
    countryLoading: false,
    leagueSearchResults: [],
    leagueLoading: false,
    team1SearchResults: [],
    team1Loading: false,
    team2SearchResults: [],
    team2Loading: false
  }
]);

// Variables pour les événements multiples (paris combinés)
const events = ref([]);
const currentEvent = ref({
  sport_id: null,
  country_id: null,
  league: null,
  team1: null,
  team2: null,
  bet_type: null,
  bet_code: '',
  description: '',
  result: null,
  odds: null
});

// Données du formulaire
const formData = ref({
  bet_date: new Date(),
  sport_id: null,
  country_id: null,
  league: null,
  team1: null,
  team2: null,
  bet_type: null,
  global_odds: null,
  stake: null,
  result: resultValues.PENDING
});



// Options pour le résultat maintenant fournies par le composable useBetResults

// Computed
// Variable visible supprimée car ce n'est plus un Dialog

const potentialWin = computed(() => {
  let stake = 0;
  
  if (betTypeValue.value === 'percentage' && calculatedStake.value > 0) {
    // Utiliser la mise calculée en pourcentage
    stake = calculatedStake.value;
  } else if (betTypeValue.value === 'currency' && formData.value.stake) {
    // Utiliser la mise en devise
    stake = parseFloat(formData.value.stake);
  }
  
  if (stake > 0 && formData.value.global_odds) {
    return stake * parseFloat(formData.value.global_odds);
  }
  return 0;
});

// Afficher les champs sport conditionnels
const showSportFields = computed(() => {
  return formData.value.sport_id !== null;
});

// Types de paris filtrés en fonction du sport sélectionné
const filteredBetTypes = computed(() => {
  // Si aucun sport n'est sélectionné, afficher tous les types de paris
  if (!formData.value.sport_id) {
    return allBetTypeOptions.value;
  }
  
  // Trouver le sport sélectionné dans la liste des sports disponibles
  const selectedSport = availableSports.value.find(sport => sport.id === formData.value.sport_id);
  if (!selectedSport || !selectedSport.slug) {
    return allBetTypeOptions.value;
  }
  
  // Obtenir les types de paris pour ce sport spécifique
  const sportBetTypes = getBetTypesForSport(selectedSport.slug);
  
  // Filtrer les options pour ne garder que celles disponibles pour ce sport
  return allBetTypeOptions.value.filter(option => 
    sportBetTypes.includes(option.value)
  );
});

/**
 * Gérer l'affichage du dropdown des types de paris
 * @param {number} eventIndex - Index de l'événement
 */
function onBetTypeDropdownShow(eventIndex) {
  console.log('🔽 Dropdown type de paris ouvert pour événement', eventIndex);
  // Pas de logique spéciale nécessaire, le Select gère automatiquement les options
}

const isFormValid = computed(() => {
  // Seuls les champs essentiels sont obligatoires
  return formData.value.bet_date &&
         formData.value.global_odds &&
         formData.value.stake;
});

/**
 * Obtenir les types de paris filtrés pour un événement spécifique
 * @param {Object} eventData - Les données de l'événement
 * @returns {Array} Les types de paris disponibles pour cet événement
 */
function getFilteredBetTypesForEvent(eventData) {
  // Si aucun sport n'est sélectionné, afficher tous les types de paris
  if (!eventData.sport_id) {
    return allBetTypeOptions.value;
  }
  
  // Trouver le sport sélectionné dans la liste des sports disponibles
  const selectedSport = availableSports.value.find(sport => sport.id === eventData.sport_id);
  if (!selectedSport || !selectedSport.slug) {
    return allBetTypeOptions.value;
  }
  
  // Obtenir les types de paris pour ce sport spécifique
  const sportBetTypes = getBetTypesForSport(selectedSport.slug);
  
  // Filtrer les options pour ne garder que celles disponibles pour ce sport
  return allBetTypeOptions.value.filter(option => 
    sportBetTypes.includes(option.value)
  );
}

// Méthodes

/**
 * Charger la liste des pays disponibles
 */
async function loadCountries() {
  try {
    const countryData = await CountryService.getCountries();
    // Utiliser les vrais IDs des pays depuis l'API
    const formattedCountries = countryData.map(country => ({
      id: country.id, // Utiliser le vrai ID du pays
      name: country.name,
      code: country.code
    }));
    
    countries.value = formattedCountries;
    allCountries.value = formattedCountries;
  } catch (error) {
    console.error('Erreur lors du chargement des pays:', error);
    toast.add({
      severity: 'error',
      summary: 'Erreur',
      detail: 'Impossible de charger les pays',
      life: 3000
    });
    countries.value = [];
    allCountries.value = [];
  }
}

/**
 * Charger les ligues d'un sport spécifique
 */
async function loadLeaguesBySport(sportId) {
  try {
    availableLeagues.value = await SportService.getLeaguesBySport(sportId);
  } catch (error) {
    console.error('Erreur lors du chargement des ligues:', error);
    toast.add({
      severity: 'error',
      summary: 'Erreur',
      detail: 'Impossible de charger les ligues',
      life: 3000
    });
    availableLeagues.value = [];
  }
}

/**
 * Charger les équipes d'un sport spécifique
 */
async function loadTeamsBySport(sportId) {
  try {
    availableTeams.value = await SportService.getTeamsBySport(sportId);
  } catch (error) {
    console.error('Erreur lors du chargement des équipes par sport:', error);
    toast.add({
      severity: 'error',
      summary: 'Erreur',
      detail: 'Impossible de charger les équipes',
      life: 3000
    });
    availableTeams.value = [];
  }
}

/**
 * Charger les équipes d'une ligue spécifique
 */
async function loadTeamsByLeague(leagueId) {
  try {
    availableTeams.value = await SportService.getTeamsByLeague(leagueId);
  } catch (error) {
    console.error('Erreur lors du chargement des équipes par ligue:', error);
    toast.add({
      severity: 'error',
      summary: 'Erreur',
      detail: 'Impossible de charger les équipes de la ligue',
      life: 3000
    });
    availableTeams.value = [];
  }
}

/**
 * Charger les pays qui ont des ligues pour un sport spécifique
 * @param {number} sportId - ID du sport
 * @param {number} eventIndex - Index de l'événement
 */
async function loadCountriesBySport(sportId, eventIndex) {
  try {
    const eventData = eventCards.value[eventIndex];
    eventData.countryLoading = true;
    
    // Vérifier si les pays sont déjà en cache pour ce sport
    if (countriesBySportCache.value.has(sportId)) {
      const cachedCountries = countriesBySportCache.value.get(sportId);
      eventData.countryFilteredResults = [...cachedCountries];
      console.log('✅ Pays récupérés depuis le cache pour le sport', sportId, ':', cachedCountries.length, 'pays');
      return;
    }
    
    // Charger depuis l'API si pas en cache
    const countriesData = await SportService.getCountriesBySport(sportId);
    
    // Mettre en cache les résultats
    countriesBySportCache.value.set(sportId, countriesData);
    
    // Mettre à jour les pays disponibles pour cette carte d'événement
    eventData.countryFilteredResults = [...countriesData];
    
    
  } catch (error) {
    console.error('Erreur lors du chargement des pays par sport:', error);
    toast.add({
      severity: 'error',
      summary: 'Erreur',
      detail: 'Impossible de charger les pays pour ce sport',
      life: 3000
    });
    const eventData = eventCards.value[eventIndex];
    eventData.countryFilteredResults = [];
  } finally {
    const eventData = eventCards.value[eventIndex];
    eventData.countryLoading = false;
  }
}

/**
 * Charger tous les sports disponibles
 */
async function loadSports() {
  
  try {
    sportsLoading.value = true;
    
    const sportsData = await SportService.getSports();
    availableSports.value = sportsData;
    
    
  } catch (error) {
    console.error('❌ Erreur lors du chargement des sports:', error);
    toast.add({
      severity: 'error',
      summary: 'Erreur',
      detail: 'Impossible de charger les sports',
      life: 3000
    });
    availableSports.value = [];
  } finally {
    sportsLoading.value = false;
  }
}

/**
 * Rechercher des sports avec filtrage
 * @param {Object} event - Événement de recherche contenant la query
 * @param {number} eventIndex - Index de l'événement
 */
function searchSports(event, eventIndex) {
  const query = event.query || '';
  const eventData = eventCards.value[eventIndex];
  
  setTimeout(() => {
    if (!query.trim().length) {
      eventData.sportSearchResults = [...availableSports.value];
    } else {
      eventData.sportSearchResults = availableSports.value.filter((sport) => {
        return sport.name.toLowerCase().includes(query.toLowerCase());
      });
    }
  }, 250);
}

/**
 * Gérer l'affichage du dropdown des sports
 * @param {number} eventIndex - Index de l'événement
 */
// Drapeaux pour éviter les appels multiples
const sportDropdownOpeningInProgress = ref({});
const countryDropdownOpeningInProgress = ref({});
const leagueDropdownOpeningInProgress = ref({});
const team1DropdownOpeningInProgress = ref({});
const team2DropdownOpeningInProgress = ref({});

function onSportDropdownShow(eventIndex) {
  // Vérifier si l'ouverture est déjà en cours pour cet événement
  if (sportDropdownOpeningInProgress.value[eventIndex]) {
    return; // Éviter les appels multiples
  }
  
  // Marquer l'ouverture comme en cours
  sportDropdownOpeningInProgress.value[eventIndex] = true;
  
  console.log('🔽 Dropdown sports ouvert pour événement', eventIndex);
  const eventData = eventCards.value[eventIndex];
  
  // Charger tous les sports si pas encore chargés
  if (!eventData.sportSearchResults || eventData.sportSearchResults.length === 0) {
    eventData.sportSearchResults = [...availableSports.value];
  }
  
  // Forcer l'ouverture du dropdown en utilisant la référence
  nextTick(() => {
    const sportRef = sportAutoCompleteRefs.value[eventIndex];
    if (sportRef && typeof sportRef.show === 'function') {
      sportRef.show();
      console.log('✅ Dropdown sport forcé à s\'ouvrir');
    } else if (sportRef && sportRef.$el) {
      // Essayer de déclencher un focus sur l'élément input
      const inputElement = sportRef.$el.querySelector('input');
      if (inputElement) {
        inputElement.focus();
        inputElement.click();
        console.log('✅ Focus et clic appliqués sur le champ sport');
      } else {
        console.log('❌ Élément input non trouvé dans le composant sport');
      }
    } else {
      console.log('❌ Référence du composant sport non trouvée', sportRef);
    }
    
    // Réinitialiser le drapeau après un court délai
    setTimeout(() => {
      sportDropdownOpeningInProgress.value[eventIndex] = false;
    }, 300);
  });
}

/**
 * Gérer la sélection d'un sport
 * @param {Object} event - Événement de sélection
 * @param {number} eventIndex - Index de l'événement
 */
async function onSportSelect(event, eventIndex) {
  const eventData = eventCards.value[eventIndex];
  
  // Gérer la sélection d'un sport unique (en mode multiple mais limité à 1)
  if (event.value) {
    // En mode multiple, on garde un tableau d'un seul élément
    eventData.selectedSport = [event.value];
    eventData.sport_id = event.value.id;
    
    // Charger immédiatement les ligues pour ce sport
    console.log('🔄 Chargement immédiat des ligues après sélection du sport');
    searchLeagues({ query: '' }, eventIndex);
    
    // Empêcher la réouverture du dropdown en marquant l'ouverture comme en cours
    sportDropdownOpeningInProgress.value[eventIndex] = true;
    
    // Fermer le dropdown après sélection
    const sportRef = sportAutoCompleteRefs.value[eventIndex];
    if (sportRef) {
      // Utiliser nextTick pour s'assurer que la fermeture se produit après le rendu
      nextTick(() => {
        if (typeof sportRef.hide === 'function') {
          sportRef.hide();
          console.log('✅ Dropdown sport fermé après sélection');
        } else if (sportRef.$el) {
          // Alternative: forcer la fermeture en retirant le focus
          const inputElement = sportRef.$el.querySelector('input');
          if (inputElement) {
            inputElement.blur();
            console.log('✅ Dropdown sport fermé par blur');
          }
        }
        
        // Réinitialiser le drapeau après un délai pour permettre de futures ouvertures
        setTimeout(() => {
          sportDropdownOpeningInProgress.value[eventIndex] = false;
        }, 300);
      });
    }
  } else {
    eventData.selectedSport = [];
    eventData.sport_id = null;
    console.log('✅ Sport désélectionné pour événement', eventIndex);
  }
  
  // Réinitialiser les champs liés au sport pour cette card
  eventData.country_id = null;
  eventData.league = null;
  eventData.team1 = null;
  eventData.team2 = null;
  
  // Réinitialiser la recherche de pays pour cette card
  eventData.selectedCountry = [];
  eventData.countryFilteredResults = [];
  
  // Réinitialiser la recherche de ligues pour cette card
  eventData.selectedLeague = [];
  eventData.leagueSearchResults = [];
  
  // Réinitialiser la recherche d'équipes pour cette card
  eventData.selectedTeam1 = [];
  eventData.team1SearchResults = [];
  eventData.selectedTeam2 = [];
  eventData.team2SearchResults = [];
  
  // Charger les données du sport sélectionné
  if (eventData.sport_id) {
    // Charger les pays qui ont des ligues pour ce sport
    await loadCountriesBySport(eventData.sport_id, eventIndex);
    await loadTeamsBySport(eventData.sport_id);
    // Charger les premières ligues
    await searchLeagues({ query: '' }, eventIndex);
    // Charger les premières équipes pour les deux sélecteurs
    await searchTeam1({ query: '' }, eventIndex);
    await searchTeam2({ query: '' }, eventIndex);
  }
}

/**
 * Gérer le changement de sport (fonction de compatibilité)
 * @param {Object} event - Événement de changement
 * @param {number} eventIndex - Index de l'événement
 */
async function onSportChange(event, eventIndex) {
  // Cette fonction est maintenant gérée par onSportSelect
  console.log('⚠️ onSportChange appelée - redirection vers onSportSelect');
  await onSportSelect(event, eventIndex);
}

/**
 * Gérer l'affichage du dropdown des pays
 * @param {number} eventIndex - Index de l'événement
 */
// Utilisation du drapeau existant pour éviter les appels multiples

function onCountryDropdownShow(eventIndex) {
  // Vérifier si l'ouverture est déjà en cours pour cet événement
  if (countryDropdownOpeningInProgress.value[eventIndex]) {
    return;
  }
  
  // Marquer l'ouverture comme en cours
  countryDropdownOpeningInProgress.value[eventIndex] = true;
  
  console.log('🔽 Dropdown pays ouvert pour événement', eventIndex);
  const eventData = eventCards.value[eventIndex];
  
  // Si aucun sport sélectionné, ne rien faire
  if (!eventData.sport_id) {
    // Réinitialiser le drapeau après un court délai
    setTimeout(() => {
      countryDropdownOpeningInProgress.value[eventIndex] = false;
    }, 300);
    return;
  }
  
  // Charger les pays depuis le cache si disponibles
  const cachedCountries = countriesBySportCache.value.get(eventData.sport_id) || [];
  if (cachedCountries.length > 0 && (!eventData.countryFilteredResults || eventData.countryFilteredResults.length === 0)) {
    eventData.countryFilteredResults = [...cachedCountries];
  }
  
  // Forcer l'ouverture du dropdown en utilisant la référence
  nextTick(() => {
    const countryRef = countryAutoCompleteRefs.value[eventIndex];
    if (countryRef && typeof countryRef.show === 'function') {
      countryRef.show();
      console.log('✅ Dropdown pays forcé à s\'ouvrir');
    } else if (countryRef && countryRef.$el) {
      // Essayer de déclencher un focus sur l'élément input
      const inputElement = countryRef.$el.querySelector('input');
      if (inputElement) {
        inputElement.focus();
        inputElement.click();
        console.log('✅ Focus et clic appliqués sur le champ pays');
      } else {
        console.log('❌ Élément input non trouvé dans le composant pays');
      }
    } else {
      console.log('❌ Référence du composant pays non trouvée', countryRef);
    }
    
    // Réinitialiser le drapeau après un court délai
    setTimeout(() => {
      countryDropdownOpeningInProgress.value[eventIndex] = false;
    }, 300);
  });
}

/**
 * Rechercher des pays avec filtrage côté client utilisant le cache
 * @param {Object} event - Événement de recherche contenant la query
 * @param {number} eventIndex - Index de l'événement
 */
function searchCountries(event, eventIndex) {
  const query = event.query || '';
  const eventData = eventCards.value[eventIndex];
  
  // Si aucun sport n'est sélectionné, ne pas afficher de pays
  if (!eventData.sport_id) {
    eventData.countryFilteredResults = [];
    return;
  }
  
  // Récupérer les pays depuis le cache pour ce sport
  const cachedCountries = countriesBySportCache.value.get(eventData.sport_id) || [];
  
  setTimeout(() => {
    if (!query.trim().length) {
      // Afficher tous les pays disponibles pour ce sport depuis le cache
      eventData.countryFilteredResults = [...cachedCountries];
    } else {
      // Filtrer les pays depuis le cache
      eventData.countryFilteredResults = cachedCountries.filter((country) => {
        return country.name.toLowerCase().includes(query.toLowerCase());
      });
    }
  }, 250);
}

/**
 * Gérer la sélection d'un pays
 * @param {Object} event - Événement de sélection contenant le pays
 */
/**
 * Gérer la sélection d'un pays
 * @param {Object} event - Événement de sélection
 * @param {number} eventIndex - Index de l'événement
 */
function onCountrySelect(event, eventIndex) {
  const eventData = eventCards.value[eventIndex];
  
  // Remplacer l'élément existant par le nouveau pays sélectionné
  if (event.value) {
    eventData.selectedCountry = [event.value]; // Remplacer par le nouveau pays
    eventData.country_id = event.value.id;
    
    // Charger immédiatement les équipes pour ce pays
    console.log('🔄 Chargement immédiat des équipes après sélection du pays');
    searchTeam1({ query: '' }, eventIndex, true);
    searchTeam2({ query: '' }, eventIndex, true);
    
    // Empêcher la réouverture du dropdown en marquant l'ouverture comme en cours
    countryDropdownOpeningInProgress.value[eventIndex] = true;
    
    // Fermer le dropdown après sélection avec nextTick pour s'assurer que le rendu est terminé
    nextTick(() => {
      const countryRef = countryAutoCompleteRefs.value[eventIndex];
      if (countryRef && typeof countryRef.hide === 'function') {
        countryRef.hide();
        console.log('✅ Dropdown pays fermé après sélection');
      } else if (countryRef && countryRef.$el) {
        // Méthode alternative: blur sur l'élément input
        const inputElement = countryRef.$el.querySelector('input');
        if (inputElement) {
          inputElement.blur();
          console.log('✅ Blur appliqué sur le champ pays pour fermeture');
        }
      }
      
      // Réinitialiser le drapeau après un délai pour permettre de futures ouvertures
      setTimeout(() => {
        countryDropdownOpeningInProgress.value[eventIndex] = false;
      }, 300);
    });
  } else {
    eventData.selectedCountry = [];
    eventData.country_id = null;
  }
  
  // Déclencher le changement de pays
  onCountryChange(eventIndex);
}

/**
 * Gérer le changement de pays
 * @param {number} eventIndex - Index de l'événement
 */
async function onCountryChange(eventIndex) {
  const eventData = eventCards.value[eventIndex];
  
  // Réinitialiser les champs liés aux ligues et équipes pour cette card
  eventData.league = null;
  eventData.team1 = null;
  eventData.team2 = null;
  
  // Réinitialiser la recherche de ligues pour cette card
  eventData.selectedLeague = [];
  eventData.leagueSearchResults = [];
  
  // Réinitialiser la recherche d'équipes pour cette card
  eventData.selectedTeam1 = [];
  eventData.team1SearchResults = [];
  
  eventData.selectedTeam2 = [];
  eventData.team2SearchResults = [];
  
  // Recharger les ligues avec le filtre de pays si un sport est sélectionné
  if (eventData.sport_id) {
    await searchLeagues({ query: '' }, eventIndex);
    await searchTeam1({ query: '' }, eventIndex);
    await searchTeam2({ query: '' }, eventIndex);
  }
}

/**
 * Rechercher des ligues avec pagination
 * @param {Object} event - Événement de recherche contenant la query
 * @param {number} eventIndex - Index de l'événement
 */
async function searchLeagues(event, eventIndex) {
  const eventData = eventCards.value[eventIndex];
  
  if (!eventData.sport_id) {
    console.log('❌ searchLeagues: Aucun sport sélectionné pour événement', eventIndex);
    return;
  }
  
  const query = event.query || '';
  console.log('🔍 searchLeagues appelée avec:', {
    query,
    sportId: eventData.sport_id,
    eventIndex
  });
  
  // Initialiser les résultats si nécessaire
  if (!eventData.leagueSearchResults) {
    eventData.leagueSearchResults = [];
  }
  
  try {
    eventData.leagueLoading = true;
    
    const response = await SportService.searchLeaguesBySport(
      eventData.sport_id,
      query,
      1,
      30,
      eventData.country_id
    );
    
    eventData.leagueSearchResults = response.data;
    
  } catch (error) {
    console.error('❌ Erreur lors de la recherche des ligues:', error);
    toast.add({
      severity: 'error',
      summary: 'Erreur',
      detail: 'Impossible de rechercher les ligues',
      life: 3000
    });
  } finally {
    eventData.leagueLoading = false;
  }
}

/**
 * Gérer la sélection d'une ligue
 * @param {Object} event - Événement de sélection contenant la ligue
 * @param {number} eventIndex - Index de l'événement
 */
async function onLeagueSelect(event, eventIndex) {
  const eventData = eventCards.value[eventIndex];
  
  // Remplacer l'élément existant par la nouvelle ligue sélectionnée
  if (event.value) {
    eventData.selectedLeague = [event.value]; // Remplacer par la nouvelle ligue
    eventData.league = event.value.id;
    
    // Empêcher la réouverture du dropdown en marquant l'ouverture comme en cours
    leagueDropdownOpeningInProgress.value[eventIndex] = true;
    
    // Fermer le dropdown après sélection
    nextTick(() => {
      const leagueRef = leagueAutoCompleteRefs.value[eventIndex];
      if (leagueRef && typeof leagueRef.hide === 'function') {
        leagueRef.hide();
        console.log('✅ Dropdown ligue fermé après sélection');
      } else if (leagueRef && leagueRef.$el) {
        // Alternative: forcer la fermeture en retirant le focus
        const inputElement = leagueRef.$el.querySelector('input');
        if (inputElement) {
          inputElement.blur();
          console.log('✅ Dropdown ligue fermé par blur');
        }
      }
      
      // Réinitialiser le drapeau après un délai pour permettre de futures ouvertures
      setTimeout(() => {
        leagueDropdownOpeningInProgress.value[eventIndex] = false;
      }, 300);
    });
  } else {
    eventData.selectedLeague = [];
    eventData.league = null;
  }
  
  // Réinitialiser les équipes sélectionnées
  eventData.team1 = null;
  eventData.team2 = null;
  eventData.selectedTeam1 = [];
  eventData.selectedTeam2 = [];
  
  // Recharger les équipes avec le filtre de ligue pour les deux sélecteurs
  await searchTeam1({ query: eventData.team1SearchQuery || '' }, eventIndex, true);
  await searchTeam2({ query: eventData.team2SearchQuery || '' }, eventIndex, true);
}

/**
 * Rechercher des équipes pour l'équipe 1 avec pagination et exclusion de l'équipe 2
 * @param {Object} event - Événement de recherche contenant la query
 * @param {number} eventIndex - Index de l'événement
 * @param {boolean} resetSearch - Forcer la réinitialisation de la recherche
 */
async function searchTeam1(event, eventIndex, resetSearch = false) {
  const eventData = eventCards.value[eventIndex];
  
  if (!eventData.sport_id) {
    console.log('❌ searchTeam1: Aucun sport sélectionné pour événement', eventIndex);
    return;
  }
  
  const query = event.query || '';
  
  // Initialiser les résultats si nécessaire
  if (!eventData.team1SearchResults || resetSearch) {
    console.log('🔄 Initialisation recherche équipe 1 pour événement', eventIndex);
    eventData.team1SearchResults = [];
  }
  
  try {
    eventData.team1Loading = true;
    
    const response = await SportService.searchTeamsBySport(
      eventData.sport_id,
      query,
      1,
      30,
      eventData.league, // Filtrer par ligue si sélectionnée
      eventData.country_id // Filtrer par pays si sélectionné
    );
    
    // Filtrer pour exclure l'équipe 2 si elle est sélectionnée
    let filteredData = response.data;
    if (eventData.team2) {
      filteredData = response.data.filter(team => team.id !== eventData.team2);
      console.log('🚫 Équipe 2 exclue des résultats équipe 1:', {
        originalCount: response.data.length,
        filteredCount: filteredData.length,
        excludedTeamId: eventData.team2
      });
    }
    
    eventData.team1SearchResults = filteredData;
    
  } catch (error) {
    console.error('❌ Erreur lors de la recherche des équipes 1:', error);
    toast.add({
      severity: 'error',
      summary: 'Erreur',
      detail: 'Impossible de rechercher les équipes',
      life: 3000
    });
  } finally {
    eventData.team1Loading = false;
  }
}

/**
 * Rechercher des équipes pour l'équipe 2 avec pagination et exclusion de l'équipe 1
 * @param {Object} event - Événement de recherche contenant la query
 * @param {number} eventIndex - Index de l'événement
 * @param {boolean} resetSearch - Forcer la réinitialisation de la recherche
 */
async function searchTeam2(event, eventIndex, resetSearch = false) {
  const eventData = eventCards.value[eventIndex];
  
  if (!eventData.sport_id) {
    return;
  }
  
  const query = event.query || '';
  
  // Initialiser les résultats si nécessaire
  if (!eventData.team2SearchResults || resetSearch) {
    eventData.team2SearchResults = [];
  }
  
  try {
    eventData.team2Loading = true;
    
    const response = await SportService.searchTeamsBySport(
      eventData.sport_id,
      query,
      1,
      30,
      eventData.league, // Filtrer par ligue si sélectionnée
      eventData.country_id // Filtrer par pays si sélectionné
    );
    
    // Filtrer pour exclure l'équipe 1 si elle est sélectionnée
    let filteredData = response.data;
    if (eventData.team1) {
      filteredData = response.data.filter(team => team.id !== eventData.team1);
    }
    
    eventData.team2SearchResults = filteredData;
    
  } catch (error) {
    console.error('❌ Erreur lors de la recherche des équipes 2:', error);
    toast.add({
      severity: 'error',
      summary: 'Erreur',
      detail: 'Impossible de rechercher les équipes',
      life: 3000
    });
  } finally {
    eventData.team2Loading = false;
  }
}

/**
 * Gérer la sélection de l'équipe 1
 * @param {Object} event - Événement de sélection contenant l'équipe
 * @param {number} eventIndex - Index de l'événement
 */
function onTeam1Select(event, eventIndex) {
  const eventData = eventCards.value[eventIndex];
  
  // Remplacer l'élément existant par la nouvelle équipe sélectionnée
  if (event.value) {
    eventData.selectedTeam1 = [event.value]; // Remplacer par la nouvelle équipe
    eventData.team1 = event.value.id;
    
    // Empêcher la réouverture du dropdown en marquant l'ouverture comme en cours
    team1DropdownOpeningInProgress.value[eventIndex] = true;
    
    // Fermer le dropdown après sélection
    nextTick(() => {
      const team1Ref = team1AutoCompleteRefs.value[eventIndex];
      if (team1Ref && typeof team1Ref.hide === 'function') {
        team1Ref.hide();
        console.log('✅ Dropdown équipe 1 fermé après sélection');
      } else if (team1Ref && team1Ref.$el) {
        // Alternative: forcer la fermeture en retirant le focus
        const inputElement = team1Ref.$el.querySelector('input');
        if (inputElement) {
          inputElement.blur();
          console.log('✅ Dropdown équipe 1 fermé par blur');
        }
      }
      
      // Réinitialiser le drapeau après un délai pour permettre de futures ouvertures
      setTimeout(() => {
        team1DropdownOpeningInProgress.value[eventIndex] = false;
      }, 300);
    });
  } else {
    eventData.selectedTeam1 = [];
    eventData.team1 = null;
  }
  
  // Rafraîchir les résultats de l'équipe 2 pour exclure l'équipe 1 sélectionnée
  if (eventData.team2SearchResults && eventData.team2SearchResults.length > 0) {
    searchTeam2({ query: eventData.team2SearchQuery || '' }, eventIndex, true);
  }
}

/**
 * Gérer la sélection de l'équipe 2
 * @param {Object} event - Événement de sélection contenant l'équipe
 * @param {number} eventIndex - Index de l'événement
 */
function onTeam2Select(event, eventIndex) {
  const eventData = eventCards.value[eventIndex];
  
  if (event.value) {
    // Empêcher la réouverture du dropdown en marquant l'ouverture comme en cours
    team2DropdownOpeningInProgress.value[eventIndex] = true;
    
    // Fermer le dropdown après sélection
    nextTick(() => {
      const team2Ref = team2AutoCompleteRefs.value[eventIndex];
      if (team2Ref && typeof team2Ref.hide === 'function') {
        team2Ref.hide();
        console.log('✅ Dropdown équipe 2 fermé après sélection');
      } else if (team2Ref && team2Ref.$el) {
        // Alternative: forcer la fermeture en retirant le focus
        const inputElement = team2Ref.$el.querySelector('input');
        if (inputElement) {
          inputElement.blur();
          console.log('✅ Dropdown équipe 2 fermé par blur');
        }
      }
      
      // Réinitialiser le drapeau après un délai pour permettre de futures ouvertures
      setTimeout(() => {
        team2DropdownOpeningInProgress.value[eventIndex] = false;
      }, 300);
    });
  }
  
  // Remplacer l'élément existant par la nouvelle équipe sélectionnée
  if (event.value) {
    eventData.selectedTeam2 = [event.value]; // Remplacer par la nouvelle équipe
    eventData.team2 = event.value.id;
  } else {
    eventData.selectedTeam2 = [];
    eventData.team2 = null;
  }
  
  // Rafraîchir les résultats de l'équipe 1 pour exclure l'équipe 2 sélectionnée
  if (eventData.team1SearchResults && eventData.team1SearchResults.length > 0) {
    searchTeam1({ query: eventData.team1SearchQuery || '' }, eventIndex, true);
  }
}

/**
 * Charger plus d'équipes 1 (pagination)
 */
async function loadMoreTeam1() {
  if (team1Loading.value || !team1HasMore.value) {
    console.log('⏸️ loadMoreTeam1: Chargement en cours ou plus de résultats');
    return;
  }
  
  console.log('📄 Chargement de la page suivante équipes 1:', team1CurrentPage.value + 1);
  team1CurrentPage.value++;
  searchTeam1({ query: team1SearchQuery.value });
}

/**
 * Charger plus d'équipes 2 (pagination)
 */
async function loadMoreTeam2() {
  if (team2Loading.value || !team2HasMore.value) {
    console.log('⏸️ loadMoreTeam2: Chargement en cours ou plus de résultats');
    return;
  }
  
  console.log('📄 Chargement de la page suivante équipes 2:', team2CurrentPage.value + 1);
  team2CurrentPage.value++;
  searchTeam2({ query: team2SearchQuery.value });
}



/**
 * Gérer l'affichage du dropdown des équipes 1
 * @param {number} eventIndex - Index de l'événement
 */
function onTeam1DropdownShow(eventIndex) {
  // Vérifier si l'ouverture est déjà en cours pour cet événement
  if (team1DropdownOpeningInProgress.value[eventIndex]) {
    return; // Éviter les appels multiples
  }
  
  // Marquer l'ouverture comme en cours
  team1DropdownOpeningInProgress.value[eventIndex] = true;
  
  console.log('🔽 Dropdown équipes 1 ouvert pour événement', eventIndex);
  
  // Forcer l'ouverture du dropdown en utilisant la référence
  nextTick(() => {
    const team1Ref = team1AutoCompleteRefs.value[eventIndex];
    if (team1Ref && typeof team1Ref.show === 'function') {
      team1Ref.show();
      console.log('✅ Dropdown équipe 1 ouvert manuellement');
    }
  });
  
  // Réinitialiser le drapeau après un délai
  setTimeout(() => {
    team1DropdownOpeningInProgress.value[eventIndex] = false;
  }, 300);
  const eventData = eventCards.value[eventIndex];
  if ((!eventData.team1SearchResults || eventData.team1SearchResults.length === 0) && eventData.sport_id) {
    console.log('🔄 Chargement initial des équipes 1 au dropdown');
    searchTeam1({ query: '' }, eventIndex, true);
  }
}

/**
 * Gérer l'affichage du dropdown des équipes 2
 * @param {number} eventIndex - Index de l'événement
 */
function onTeam2DropdownShow(eventIndex) {
  // Vérifier si l'ouverture est déjà en cours pour cet événement
  if (team2DropdownOpeningInProgress.value[eventIndex]) {
    return; // Éviter les appels multiples
  }
  
  // Marquer l'ouverture comme en cours
  team2DropdownOpeningInProgress.value[eventIndex] = true;
  
  console.log('🔽 Dropdown équipes 2 ouvert pour événement', eventIndex);
  
  // Forcer l'ouverture du dropdown en utilisant la référence
  nextTick(() => {
    const team2Ref = team2AutoCompleteRefs.value[eventIndex];
    if (team2Ref && typeof team2Ref.show === 'function') {
      team2Ref.show();
      console.log('✅ Dropdown équipe 2 ouvert manuellement');
    }
  });
  
  const eventData = eventCards.value[eventIndex];
  if ((!eventData.team2SearchResults || eventData.team2SearchResults.length === 0) && eventData.sport_id) {
    console.log('🔄 Chargement initial des équipes 2 au dropdown');
    searchTeam2({ query: '' }, eventIndex, true);
  }
  
  // Réinitialiser le drapeau après un délai
  setTimeout(() => {
    team2DropdownOpeningInProgress.value[eventIndex] = false;
  }, 300);
}



/**
 * Gérer l'affichage du dropdown des ligues
 * @param {number} eventIndex - Index de l'événement
 */
function onLeagueDropdownShow(eventIndex) {
  // Vérifier si l'ouverture est déjà en cours pour cet événement
  if (leagueDropdownOpeningInProgress.value[eventIndex]) {
    return; // Éviter les appels multiples
  }
  
  // Marquer l'ouverture comme en cours
  leagueDropdownOpeningInProgress.value[eventIndex] = true;
  
  console.log('🔽 Dropdown ligues ouvert pour événement', eventIndex);
  
  // Charger les ligues si pas encore chargées pour cette card
  const eventData = eventCards.value[eventIndex];
  if (!eventData.leagueSearchResults || eventData.leagueSearchResults.length === 0) {
    searchLeagues({ query: '' }, eventIndex);
  }
  
  // Forcer l'ouverture du dropdown en utilisant la référence
  nextTick(() => {
    const leagueRef = leagueAutoCompleteRefs.value[eventIndex];
    if (leagueRef && typeof leagueRef.show === 'function') {
      leagueRef.show();
      console.log('✅ Dropdown ligue forcé à s\'ouvrir');
    } else if (leagueRef && leagueRef.$el) {
      // Essayer de déclencher un focus sur l'élément input
      const inputElement = leagueRef.$el.querySelector('input');
      if (inputElement) {
        inputElement.focus();
        inputElement.click();
        console.log('✅ Focus et clic appliqués sur le champ ligue');
      } else {
        console.log('❌ Élément input non trouvé dans le composant ligue');
      }
    } else {
      console.log('❌ Référence du composant ligue non trouvée', leagueRef);
    }
  });
  
  // Réinitialiser le drapeau après un délai
  setTimeout(() => {
    leagueDropdownOpeningInProgress.value[eventIndex] = false;
  }, 300);
}



/**
 * Gérer le défilement du panel équipes 1 pour le lazy loading
 * @param {Event} event - Événement de défilement
 */
function handleTeam1PanelScroll(event) {
  const panel = event.target;
  const scrollTop = panel.scrollTop;
  const scrollHeight = panel.scrollHeight;
  const clientHeight = panel.clientHeight;
  
  // Calculer le pourcentage de défilement
  const scrollPercentage = (scrollTop + clientHeight) / scrollHeight;
  
  console.log('📊 Scroll équipes 1 détecté:', {
    scrollTop,
    scrollHeight,
    clientHeight,
    scrollPercentage: Math.round(scrollPercentage * 100) + '%',
    hasMore: team1HasMore.value,
    loading: team1Loading.value,
    currentPage: team1CurrentPage.value,
    resultsCount: team1SearchResults.value.length
  });
  
  // Si on a atteint 90% du défilement et qu'il y a plus de données
  if (scrollPercentage >= 0.9) {
    console.log('🎯 90% atteint pour équipes 1! État actuel:', {
      hasMore: team1HasMore.value,
      loading: team1Loading.value,
      willTrigger: team1HasMore.value && !team1Loading.value
    });
    
    if (team1HasMore.value && !team1Loading.value) {
      console.log('🚀 Déclenchement du lazy loading équipes 1...');
      loadMoreTeam1();
    } else {
      console.log('❌ Lazy loading équipes 1 non déclenché:', {
        reason: !team1HasMore.value ? 'Pas de données supplémentaires' : 'Chargement en cours'
      });
    }
  }
}

/**
 * Gérer le défilement du panel équipes 2 pour le lazy loading
 * @param {Event} event - Événement de défilement
 */
function handleTeam2PanelScroll(event) {
  const panel = event.target;
  const scrollTop = panel.scrollTop;
  const scrollHeight = panel.scrollHeight;
  const clientHeight = panel.clientHeight;
  
  // Calculer le pourcentage de défilement
  const scrollPercentage = (scrollTop + clientHeight) / scrollHeight;
  
  console.log('📊 Scroll équipes 2 détecté:', {
    scrollTop,
    scrollHeight,
    clientHeight,
    scrollPercentage: Math.round(scrollPercentage * 100) + '%',
    hasMore: team2HasMore.value,
    loading: team2Loading.value,
    currentPage: team2CurrentPage.value,
    resultsCount: team2SearchResults.value.length
  });
  
  // Si on a atteint 90% du défilement et qu'il y a plus de données
  if (scrollPercentage >= 0.9) {
    console.log('🎯 90% atteint pour équipes 2! État actuel:', {
      hasMore: team2HasMore.value,
      loading: team2Loading.value,
      willTrigger: team2HasMore.value && !team2Loading.value
    });
    
    if (team2HasMore.value && !team2Loading.value) {
      console.log('🚀 Déclenchement du lazy loading équipes 2...');
      loadMoreTeam2();
    } else {
      console.log('❌ Lazy loading équipes 2 non déclenché:', {
        reason: !team2HasMore.value ? 'Pas de données supplémentaires' : 'Chargement en cours'
      });
    }
  }
}

/**
 * Gérer la saisie de la cote pour remplacer immédiatement les virgules par des points
 * @param {Event} event - Événement d'input
 */
function handleOddsInput(event) {
  let inputValue = event.target.value;
  console.log('handleOddsInput - Valeur tapée:', inputValue);
  
  // Remplacer immédiatement toutes les virgules par des points
  const normalizedValue = inputValue.replace(/,/g, '.');
  console.log('handleOddsInput - Valeur normalisée:', normalizedValue);
  
  // Si une virgule a été détectée, forcer le remplacement immédiat
  if (inputValue !== normalizedValue) {
    console.log('handleOddsInput - Virgule détectée, remplacement en cours...');
    // Sauvegarder la position du curseur
    const cursorPosition = event.target.selectionStart;
    
    // Mettre à jour immédiatement la valeur de l'input
    event.target.value = normalizedValue;
    
    // Restaurer la position du curseur
    event.target.setSelectionRange(cursorPosition, cursorPosition);
    
    // Mettre à jour le v-model
    formData.value.global_odds = normalizedValue;
    console.log('handleOddsInput - Remplacement terminé, nouvelle valeur:', event.target.value);
    return;
  }
  
  // Vérifier que la valeur est un nombre réel valide
  if (normalizedValue === '' || normalizedValue === '.') {
    formData.value.global_odds = null;
    return;
  }
  
  // Validation du format nombre réel
  const numericValue = parseFloat(normalizedValue);
  if (!isNaN(numericValue) && isFinite(numericValue) && numericValue > 0) {
    formData.value.global_odds = numericValue;
  } else {
    // Si la valeur n'est pas valide, on garde la dernière valeur valide
    console.warn('Valeur de cote invalide:', normalizedValue);
  }
}

/**
 * Gérer la saisie de la mise pour accepter les virgules et les points comme séparateurs décimaux
 * @param {Event} event - Événement d'input
 */
function handleStakeInput(event) {
  let inputValue = event.target.value;
  console.log('handleStakeInput - Valeur tapée:', inputValue);
  
  // Remplacer immédiatement toutes les virgules par des points
  const normalizedValue = inputValue.replace(/,/g, '.');
  console.log('handleStakeInput - Valeur normalisée:', normalizedValue);
  
  // Si une virgule a été détectée, forcer le remplacement immédiat
  if (inputValue !== normalizedValue) {
    console.log('handleStakeInput - Virgule détectée, remplacement en cours...');
    // Sauvegarder la position du curseur
    const cursorPosition = event.target.selectionStart;
    
    // Mettre à jour immédiatement la valeur de l'input
    event.target.value = normalizedValue;
    
    // Restaurer la position du curseur
    event.target.setSelectionRange(cursorPosition, cursorPosition);
    
    // Mettre à jour le v-model
    formData.value.stake = normalizedValue;
    console.log('handleStakeInput - Remplacement terminé, nouvelle valeur:', event.target.value);
    return;
  }
  
  // Vérifier que la valeur est un nombre réel valide
  if (normalizedValue === '' || normalizedValue === '.') {
    formData.value.stake = null;
    return;
  }
  
  // Validation du format nombre réel (la mise peut être 0)
  const numericValue = parseFloat(normalizedValue);
  if (!isNaN(numericValue) && isFinite(numericValue) && numericValue >= 0) {
    formData.value.stake = numericValue;
  } else {
    // Si la valeur n'est pas valide, on garde la dernière valeur valide
    console.warn('Valeur de mise invalide:', normalizedValue);
  }
}

/**
 * Gérer la saisie de la cote d'événement pour remplacer immédiatement les virgules par des points
 * @param {Event} event - Événement d'input
 * @param {number} eventIndex - Index de l'événement
 */
function handleEventOddsInput(event, eventIndex) {
  let inputValue = event.target.value;
  console.log('handleEventOddsInput - Valeur tapée:', inputValue, 'pour événement', eventIndex);
  
  const eventData = eventCards.value[eventIndex];
  
  // Remplacer immédiatement toutes les virgules par des points
  const normalizedValue = inputValue.replace(/,/g, '.');
  console.log('handleEventOddsInput - Valeur normalisée:', normalizedValue);
  
  // Si une virgule a été détectée, forcer le remplacement immédiat
  if (inputValue !== normalizedValue) {
    console.log('handleEventOddsInput - Virgule détectée, remplacement en cours...');
    // Sauvegarder la position du curseur
    const cursorPosition = event.target.selectionStart;
    
    // Mettre à jour immédiatement la valeur de l'input
    event.target.value = normalizedValue;
    
    // Restaurer la position du curseur
    event.target.setSelectionRange(cursorPosition, cursorPosition);
    
    // Mettre à jour le v-model
    eventData.odds = normalizedValue;
    console.log('handleEventOddsInput - Remplacement terminé, nouvelle valeur:', event.target.value);
    return;
  }
  
  // Vérifier que la valeur est un nombre réel valide
  if (normalizedValue === '' || normalizedValue === '.') {
    eventData.odds = null;
    // Recalculer la cote globale même avec une valeur vide
    calculateGlobalOdds();
    return;
  }
  
  // Validation du format nombre réel
  const numericValue = parseFloat(normalizedValue);
  if (!isNaN(numericValue) && isFinite(numericValue) && numericValue > 0) {
    eventData.odds = numericValue;
  } else {
    // Si la valeur n'est pas valide, on garde la dernière valeur valide
    console.warn('Valeur de cote d\'événement invalide:', normalizedValue);
  }
  
  // Recalculer la cote globale
  calculateGlobalOdds();
}

/**
 * Gérer les touches pressées pour la cote globale (permettre point et virgule)
 * @param {KeyboardEvent} event - Événement de frappe
 */
function handleOddsKeypress(event) {
  const char = String.fromCharCode(event.which);
  const currentValue = event.target.value;
  
  // Permettre les chiffres, le point, la virgule et les touches de contrôle
  if (!/[0-9.,]/.test(char) && event.which !== 8 && event.which !== 46 && event.which !== 37 && event.which !== 39) {
    event.preventDefault();
    return;
  }
  
  // Empêcher plusieurs séparateurs décimaux (point ou virgule)
  if ((char === '.' || char === ',') && (currentValue.includes('.') || currentValue.includes(','))) {
    event.preventDefault();
    return;
  }
  
  // Empêcher le point/virgule en première position
  if ((char === '.' || char === ',') && currentValue === '') {
    event.preventDefault();
    return;
  }
}

/**
 * Gérer les touches pressées pour la mise (permettre point et virgule)
 * @param {KeyboardEvent} event - Événement de frappe
 */
function handleStakeKeypress(event) {
  const char = String.fromCharCode(event.which);
  const currentValue = event.target.value;
  
  // Permettre les chiffres, le point, la virgule et les touches de contrôle
  if (!/[0-9.,]/.test(char) && event.which !== 8 && event.which !== 46 && event.which !== 37 && event.which !== 39) {
    event.preventDefault();
    return;
  }
  
  // Empêcher plusieurs séparateurs décimaux (point ou virgule)
  if ((char === '.' || char === ',') && (currentValue.includes('.') || currentValue.includes(','))) {
    event.preventDefault();
    return;
  }
  
  // Empêcher le point/virgule en première position
  if ((char === '.' || char === ',') && currentValue === '') {
    event.preventDefault();
    return;
  }
}

/**
 * Gérer les touches pressées pour la cote d'événement (permettre point et virgule)
 * @param {KeyboardEvent} event - Événement de frappe
 */
function handleEventOddsKeypress(event) {
  const char = String.fromCharCode(event.which);
  const currentValue = event.target.value;
  
  // Permettre les chiffres, le point, la virgule et les touches de contrôle
  if (!/[0-9.,]/.test(char) && event.which !== 8 && event.which !== 46 && event.which !== 37 && event.which !== 39) {
    event.preventDefault();
    return;
  }
  
  // Empêcher plusieurs séparateurs décimaux (point ou virgule)
  if ((char === '.' || char === ',') && (currentValue.includes('.') || currentValue.includes(','))) {
    event.preventDefault();
    return;
  }
  
  // Empêcher le point/virgule en première position
  if ((char === '.' || char === ',') && currentValue === '') {
    event.preventDefault();
    return;
  }
}



/**
 * Gérer l'ouverture du dropdown pour attacher le scroll listener
 */
function onDropdownShow() {
  console.log('🔍 Dropdown ouvert, recherche du panel...');
  
  // Fonction pour rechercher le panel
  const findAndAttachListener = () => {
    // Utiliser le bon sélecteur basé sur la structure DOM observée
    const panel = document.querySelector('.p-autocomplete-list-container');
    console.log('🔍 Panel trouvé (.p-autocomplete-list-container):', panel);
    
    if (panel && !panel.hasScrollListener) {
      panel.hasScrollListener = true;
      panel.addEventListener('scroll', handlePanelScroll);
      console.log('✅ Scroll listener attaché au panel');
      return true;
    } else if (panel && panel.hasScrollListener) {
      console.log('⚠️ Scroll listener déjà attaché');
      return true;
    } else {
      console.log('❌ Aucun panel trouvé avec les sélecteurs testés');
      return false;
    }
  };
  
  // Essayer immédiatement avec nextTick
  nextTick(() => {
    if (!findAndAttachListener()) {
      // Si pas trouvé, essayer avec un délai
      console.log('⏰ Nouvelle tentative dans 100ms...');
      setTimeout(() => {
        if (!findAndAttachListener()) {
          console.log('⏰ Dernière tentative dans 300ms...');
          setTimeout(findAndAttachListener, 300);
        }
      }, 100);
    }
  });
}



/**
 * Charger plus de ligues (pagination)
 */
async function loadMoreLeagues() {
  console.log('🚀 loadMoreLeagues appelée avec état:', {
    sportId: formData.value.sport_id,
    hasMore: leagueHasMore.value,
    loading: leagueLoading.value,
    currentPage: leagueCurrentPage.value,
    query: leagueSearchQuery.value,
    currentResultsCount: leagueSearchResults.value.length
  });
  
  if (!formData.value.sport_id || !leagueHasMore.value || leagueLoading.value) {
    console.log('❌ loadMoreLeagues bloquée:', {
      noSport: !formData.value.sport_id,
      noMore: !leagueHasMore.value,
      alreadyLoading: leagueLoading.value
    });
    return;
  }
  
  try {
    leagueLoading.value = true;
    leagueCurrentPage.value++;
    
    console.log('🚀 Chargement page', leagueCurrentPage.value, 'pour query:', leagueSearchQuery.value);
    
    const response = await SportService.searchLeaguesBySport(
      formData.value.sport_id,
      leagueSearchQuery.value,
      leagueCurrentPage.value,
      30,
      formData.value.country_id
    );
    
    console.log('📡 loadMoreLeagues - Réponse API:', {
      data: response.data,
      dataLength: response.data?.length,
      hasMore: response.hasMore,
      pagination: response.pagination,
      fullResponse: response
    });
    
    // Ajouter les nouveaux résultats à la liste existante
    const previousCount = leagueSearchResults.value.length;
    leagueSearchResults.value = [...leagueSearchResults.value, ...response.data];
    leagueHasMore.value = response.hasMore;
    
    console.log('✅ Page chargée:', {
      newLeagues: response.data.length,
      previousTotal: previousCount,
      newTotal: leagueSearchResults.value.length,
      hasMoreAfter: leagueHasMore.value
    });
    
  } catch (error) {
    console.error('❌ Erreur lors du chargement de plus de ligues:', error);
    // Revenir à la page précédente en cas d'erreur
    leagueCurrentPage.value--;
    console.log('🔄 Page remise à:', leagueCurrentPage.value);
  } finally {
    leagueLoading.value = false;
    console.log('🏁 loadMoreLeagues: loading terminé');
  }
}

/**
 * Gérer le défilement du panneau pour le lazy loading
 * @param {Event} event - Événement de défilement
 */
function handlePanelScroll(event) {
  const panel = event.target;
  const scrollTop = panel.scrollTop;
  const scrollHeight = panel.scrollHeight;
  const clientHeight = panel.clientHeight;
  
  // Calculer le pourcentage de défilement
  const scrollPercentage = (scrollTop + clientHeight) / scrollHeight;
  
  console.log('📊 Scroll détecté:', {
    scrollTop,
    scrollHeight,
    clientHeight,
    scrollPercentage: Math.round(scrollPercentage * 100) + '%',
    hasMore: leagueHasMore.value,
    loading: leagueLoading.value,
    currentPage: leagueCurrentPage.value,
    resultsCount: leagueSearchResults.value.length
  });
  
  // Si on a atteint 90% du défilement et qu'il y a plus de données
  if (scrollPercentage >= 0.9) {
    console.log('🎯 90% atteint! État actuel:', {
      hasMore: leagueHasMore.value,
      loading: leagueLoading.value,
      willTrigger: leagueHasMore.value && !leagueLoading.value
    });
    
    if (leagueHasMore.value && !leagueLoading.value) {
      console.log('🚀 Déclenchement du lazy loading...');
      loadMoreLeagues();
    } else {
      console.log('❌ Lazy loading non déclenché:', {
        reason: !leagueHasMore.value ? 'Pas de données supplémentaires' : 'Chargement en cours'
      });
    }
  }
}

/**
 * Gérer le changement de ligue (méthode legacy, gardée pour compatibilité)
 */
async function onLeagueChange() {
  // Réinitialiser les équipes sélectionnées
  formData.value.team1 = null;
  formData.value.team2 = null;
  
  // Si une ligue est sélectionnée, charger ses équipes
  if (formData.value.league) {
    await loadTeamsByLeague(formData.value.league);
  } else if (formData.value.sport_id) {
    // Sinon, charger toutes les équipes du sport
    await loadTeamsBySport(formData.value.sport_id);
  }
}

/**
 * Valider le formulaire
 */
function validateForm() {
  console.log('🔍 validateForm appelée');
  errors.value = {};
  
  if (!formData.value.bet_date) {
    errors.value.bet_date = 'La date du pari est requise';
  }
  
  // Validation optionnelle des équipes (seulement si les deux sont remplies)
  if (formData.value.team1 && formData.value.team2 && formData.value.team1 === formData.value.team2) {
    errors.value.team1 = 'Les deux équipes doivent être différentes';
    errors.value.team2 = 'Les deux équipes doivent être différentes';
  }
  

  
  if (!formData.value.global_odds || formData.value.global_odds < 1) {
    errors.value.global_odds = 'La cote doit être supérieure ou égale à 1';
  }
  
  if (!formData.value.stake || formData.value.stake <= 0) {
    errors.value.stake = 'La mise doit être supérieure à 0';
  }
  
  const isValid = Object.keys(errors.value).length === 0;
  console.log('📊 Erreurs de validation:', errors.value);
  console.log('✅ Formulaire valide:', isValid);
  return isValid;
}

/**
 * Soumettre le formulaire
 */
async function submitForm() {
  console.log('🔄 submitForm appelée');
  console.log('📋 Données du formulaire:', formData.value);
  console.log('✅ isFormValid:', isFormValid.value);
  
  if (!validateForm()) {
    console.log('❌ Validation échouée');
    return;
  }
  
  console.log('✅ Validation réussie, début de l\'envoi');
  loading.value = true;
  
  try {
    // Préparer les données pour l'API
    const betData = {
      bet_date: formData.value.bet_date.toISOString().split('T')[0], // Format YYYY-MM-DD
      bet_code: events.value.length > 0 ? `Pari combiné (${events.value.length} événements)` : (currentEvent.value.description || formData.value.description || 'Pari libre'),
      global_odds: parseFloat(formData.value.global_odds),
      stake: parseFloat(formData.value.stake),
      stake_type: betTypeValue.value, // Type de mise: 'currency' ou 'percentage'
      result: formData.value.result || 'pending',
      events: eventCards.value.map(eventData => ({
        id: eventData.id,
        sport_id: eventData.sport_id,
        country_id: eventData.country_id,
        league_id: eventData.league,
        team1_id: eventData.team1,
        team2_id: eventData.team2,
        description: eventData.description,
        result: eventData.result,
        odds: eventData.odds
      })) // Array d'événements basé sur eventCards
    };
    
    console.log('📤 Données envoyées à l\'API:', betData);
    
    const response = await BetService.createBet(betData);
    
    console.log('📥 Réponse reçue de l\'API:', response);
    
    if (response.success) {
      toast.add({
        severity: 'success',
        summary: 'Succès',
        detail: 'Pari ajouté avec succès - Données reçues: ' + JSON.stringify(response.data),
        life: 5000
      });
      
      // Émettre l'événement pour informer le parent
      emit('bet-created', response.data);
      
      // Fermer la dialog
      closeDialog();
    } else {
      throw new Error('Erreur lors de la création du pari');
    }
  } catch (error) {
    console.error('❌ Erreur lors de la création du pari:', error);
    toast.add({
      severity: 'error',
      summary: 'Erreur',
      detail: 'Impossible de créer le pari: ' + error.message,
      life: 5000
    });
  } finally {
    loading.value = false;
  }
}

/**
 * Fermer la dialog
 */
function closeDialog() {
  emit('closeDialog');
}

/**
 * Réinitialiser le formulaire
 */
function resetForm() {
  formData.value = {
    bet_date: new Date(),
    sport_id: null,
    country_id: null,
    league: null,
    team1: null,
    team2: null,
    global_odds: null,
    stake: null,
    result: 'pending'
  };
  errors.value = {};
  availableLeagues.value = [];
  availableTeams.value = [];
  
  // Réinitialiser les événements et l'événement actuel
  events.value = [];
  currentEvent.value = {
    sport_id: null,
    country_id: null,
    league: null,
    team1: null,
    team2: null,
    bet_code: '',
    description: '',
    result: null,
    odds: null
  };
  
  // Réinitialiser les variables de recherche de pays
  selectedCountry.value = null;
  countrySearchResults.value = [];
  countrySearchQuery.value = '';
  countryCurrentPage.value = 1;
  countryHasMore.value = false;
  countryLoading.value = false;
  
  // Réinitialiser les variables de recherche de ligues
  selectedLeague.value = null;
  leagueSearchResults.value = [];
  leagueSearchQuery.value = '';
  leagueCurrentPage.value = 1;
  leagueHasMore.value = false;
  leagueLoading.value = false;
  
  // Réinitialiser les variables de recherche d'équipes
  selectedTeam1.value = [];
  selectedTeam2.value = [];
  teamSearchResults.value = [];
  teamSearchQuery.value = '';
  teamCurrentPage.value = 1;
  teamHasMore.value = false;
  teamLoading.value = false;
  
  // Nettoyer les event listeners
  cleanupScrollListeners();
}

/**
 * Nettoyer les event listeners de scroll
 */
function cleanupScrollListeners() {
  const panels = document.querySelectorAll('.p-autocomplete-panel .p-autocomplete-items, .p-autocomplete-list-container');
  panels.forEach(panel => {
    if (panel.hasScrollListener) {
      panel.removeEventListener('scroll', handlePanelScroll);
      panel.hasScrollListener = false;
    }
    if (panel.hasTeam1ScrollListener) {
      panel.removeEventListener('scroll', handleTeam1PanelScroll);
      panel.hasTeam1ScrollListener = false;
    }
    if (panel.hasTeam2ScrollListener) {
      panel.removeEventListener('scroll', handleTeam2PanelScroll);
      panel.hasTeam2ScrollListener = false;
    }

  });
}

/**
 * Supprimer la ligue sélectionnée
 */
function clearLeague() {
  selectedLeague.value = null;
  formData.value.league = null;
  // Réinitialiser les équipes quand on supprime la ligue
  selectedTeam1.value = [];
  selectedTeam2.value = [];
  formData.value.team1 = null;
  formData.value.team2 = null;
}

/**
 * Supprimer l'équipe 1 sélectionnée
 */
function clearTeam1() {
  selectedTeam1.value = [];
  formData.value.team1 = null;
}

/**
 * Supprimer l'équipe 2 sélectionnée
 */
function clearTeam2() {
  selectedTeam2.value = [];
  formData.value.team2 = null;
}

/**
 * Ajouter un pari combiné
 */
function addEvent() {
  // Valider que tous les champs requis sont remplis
  if (!formData.value.sport_id || !formData.value.league || !formData.value.team1 || !formData.value.team2 || !currentEvent.value.description) {
    toast.add({
      severity: 'warn',
      summary: 'Champs manquants',
      detail: 'Veuillez remplir tous les champs de l\'événement avant d\'ajouter un nouvel événement.',
      life: 3000
    });
    return;
  }

  // Créer un nouvel événement avec les données actuelles
  const newEvent = {
    id: Date.now(), // ID temporaire
    sport_id: formData.value.sport_id,
    country_id: formData.value.country_id,
    league: selectedLeague.value,
    team1: selectedTeam1.value,
    team2: selectedTeam2.value,
    bet_code: currentEvent.value.description,
    description: currentEvent.value.description,
    result: currentEvent.value.result,
    odds: currentEvent.value.odds
  };

  // Ajouter l'événement à la liste
  events.value.push(newEvent);

  // Réinitialiser les champs pour le prochain événement
  resetEventFields();

  console.log('✅ Événement ajouté:', newEvent);
   console.log('📋 Liste des événements:', events.value);
   
   // Recalculer la cote globale
   calculateGlobalOdds();
 }

/**
 * Ajouter une nouvelle card d'événement (optimisé)
 */
function addEventCard() {
  const newEventCard = {
    id: Date.now(),
    sport_id: null,
    country_id: null,
    league: null,
    team1: null,
    team2: null,
    description: '',
    result: null,
    odds: null,
    selectedSport: [],
    selectedCountry: [],
    selectedLeague: [],
    selectedTeam1: [],
    selectedTeam2: [],
    sportSearchResults: [],
    sportLoading: false,
    countryFilteredResults: [],
    countryLoading: false,
    leagueSearchResults: [],
    leagueLoading: false,
    team1SearchResults: [],
    team1Loading: false,
    team2SearchResults: [],
    team2Loading: false
  };
  
  eventCards.value.push(newEventCard);
  console.log('✅ Nouvelle card d\'événement ajoutée:', {
    cardId: newEventCard.id
  });
}

/**
 * Supprimer une card d'événement
 * @param {number} index - Index de la card à supprimer
 */
function removeEventCard(index) {
  if (eventCards.value.length > 1) {
    eventCards.value.splice(index, 1);
    console.log('🗑️ Card d\'événement supprimée à l\'index:', index);
  }
}
 
 /**
  * Supprimer un événement de la liste
  * @param {number} index - Index de l'événement à supprimer
  */
 function removeEvent(index) {
   events.value.splice(index, 1);
   
   // Recalculer la cote globale après suppression
   calculateGlobalOdds();
   
   console.log('🗑️ Événement supprimé à l\'index:', index);
   console.log('📋 Liste des événements mise à jour:', events.value);
 }

/**
 * Réinitialiser les champs de l'événement actuel
 */
function resetEventFields() {
  // Réinitialiser les champs de l'événement
  formData.value.sport_id = null;
  formData.value.country_id = null;
  formData.value.league = null;
  formData.value.team1 = null;
  formData.value.team2 = null;
  
  // Réinitialiser l'événement actuel
  currentEvent.value.description = '';
  currentEvent.value.result = null;
  currentEvent.value.odds = null;
  
  // Réinitialiser les variables de sélection
  selectedCountry.value = [];
  selectedLeague.value = [];
  selectedTeam1.value = [];
  selectedTeam2.value = [];
  
  // Réinitialiser l'événement actuel
  currentEvent.value = {
    sport_id: null,
    country_id: null,
    league: null,
    team1: null,
    team2: null,
    bet_code: '',
    result: null,
    odds: null
  };
}

/**
 * Calculer la cote globale en multipliant toutes les cotes des événements
 */
function calculateGlobalOdds() {
  if (events.value.length === 0) {
    return;
  }
  
  let globalOdds = 1;
  let hasValidOdds = true;
  
  // Inclure la cote de l'événement actuel s'il y en a une
  if (currentEvent.value.odds && currentEvent.value.odds > 0) {
    globalOdds *= parseFloat(currentEvent.value.odds);
  }
  
  // Multiplier par toutes les cotes des événements ajoutés
  events.value.forEach(event => {
    if (event.odds && event.odds > 0) {
      globalOdds *= parseFloat(event.odds);
    } else {
      hasValidOdds = false;
    }
  });
  
  // Mettre à jour la cote globale seulement si toutes les cotes sont valides
  if (hasValidOdds && globalOdds > 1) {
    formData.value.global_odds = parseFloat(globalOdds.toFixed(2));
  }
}

/**
 * Calculer le résultat global basé sur tous les résultats des événements
 */
function calculateGlobalResult() {
  if (events.value.length === 0) {
    return;
  }
  
  let hasAllResults = true;
  let hasWin = true;
  let hasLost = false;
  let hasVoid = false;
  let hasPending = false;
  
  // Inclure le résultat de l'événement actuel
  const allResults = [...events.value.map(e => e.result)];
  if (currentEvent.value.result) {
    allResults.push(currentEvent.value.result);
  }
  
  allResults.forEach(result => {
    if (!result) {
      hasAllResults = false;
      return;
    }
    
    switch (result) {
      case resultValues.LOST:
        hasLost = true;
        hasWin = false;
        break;
      case resultValues.VOID:
        hasVoid = true;
        break;
      case 'pending':
        hasPending = true;
        hasWin = false;
        break;
      case resultValues.WIN:
        // Continue à vérifier les autres
        break;
      default:
        hasWin = false;
    }
  });
  
  // Déterminer le résultat global
  if (!hasAllResults || hasPending) {
    formData.value.result = 'pending';
  } else if (hasLost) {
    formData.value.result = resultValues.LOST;
  } else if (hasVoid && hasWin) {
    formData.value.result = resultValues.WIN; // Si certains sont void mais les autres gagnés
  } else if (hasVoid) {
    formData.value.result = resultValues.VOID;
  } else if (hasWin) {
    formData.value.result = resultValues.WIN;
  }
}

/**
 * Récupérer le capital actuel de l'utilisateur
 */
async function fetchCurrentCapital() {
  try {
    capitalLoading.value = true;
    const response = await BetService.getCapitalEvolution();
    
    if (response.success && response.data) {
      currentCapital.value = response.current_capital || response.initial_capital || 0;
    }
  } catch (error) {
    console.error('Erreur lors de la récupération du capital actuel:', error);
    currentCapital.value = 0;
  } finally {
    capitalLoading.value = false;
  }
}

/**
 * Calculer la mise en pourcentage du capital
 */
function calculatePercentageStake() {
  if (betTypeValue.value === 'percentage' && formData.value.stake && currentCapital.value > 0) {
    const percentage = parseFloat(formData.value.stake);
    if (!isNaN(percentage) && percentage > 0) {
      calculatedStake.value = (currentCapital.value * percentage) / 100;
      return;
    }
  }
  calculatedStake.value = 0;
}

// Watchers
// Surveiller le changement de type de mise pour récupérer le capital
watch(betTypeValue, async (newValue) => {
  if (newValue === 'percentage') {
    await fetchCurrentCapital();
  }
  calculatePercentageStake();
});

// Surveiller les changements de la mise pour recalculer en mode pourcentage
watch(() => formData.value.stake, () => {
  calculatePercentageStake();
});

// Surveiller les changements dans les résultats des événements
watch(
  () => [events.value.map(e => e.result), currentEvent.value.result],
  () => {
    calculateGlobalResult();
  },
  { deep: true }
);

// Surveiller les changements de sport pour réinitialiser le type de pari
watch(
  () => eventCards.value.map(event => event.sport_id),
  (newSportIds, oldSportIds) => {
    // Réinitialiser le type de pari si le sport a changé
    newSportIds.forEach((newSportId, index) => {
      if (oldSportIds && oldSportIds[index] !== newSportId) {
        eventCards.value[index].bet_type = null;
      }
    });
  },
  { deep: true }
);

// Surveiller les changements de sport dans formData pour réinitialiser le type de pari
watch(
  () => formData.value.sport_id,
  (newSportId, oldSportId) => {
    if (oldSportId !== newSportId) {
      formData.value.bet_type = null;
    }
  }
);

/**
 * Charger les sports au moment de l'ouverture de la modal
 * Cette méthode est appelée par AddBetDialog lors de l'ouverture
 */
async function loadSportsOnModalOpen() {
  console.log('🚀 Chargement des sports au clic sur la modal');
  
  // Charger les sports si pas encore chargés
  if (!availableSports.value || availableSports.value.length === 0) {
    await loadSports();
  } else {
    console.log('📋 Sports déjà chargés (', availableSports.value.length, 'sports)');
  }
}

// Exposer la méthode pour qu'elle soit accessible depuis le parent
defineExpose({
  loadSportsOnModalOpen
});

// Fonction d'initialisation asynchrone
async function initializeComponent() {
  // Charger les sports et les pays au montage
  await loadSports();
  await loadCountries();
}

// Lifecycle
onMounted(() => {
  initializeComponent();
});
</script>

<style scoped>
.p-invalid {
  border-color: #ef4444;
}



/* Styles personnalisés pour les composants Select */
:deep(.select-custom .p-dropdown-panel) {
  max-width: 100% !important;
  width: auto !important;
}

:deep(.select-panel-custom) {
  max-width: calc(50vw - 4rem) !important;
  width: auto !important;
  max-height: 200px !important;
  overflow-y: auto !important;
  z-index: 9999 !important;
  position: absolute !important;
}

@media (max-width: 960px) {
  :deep(.select-panel-custom) {
    max-width: calc(90vw - 4rem) !important;
  }
}

:deep(.select-panel-custom .p-dropdown-items) {
  max-width: 100% !important;
  max-height: 180px !important;
  overflow-y: auto !important;
}

:deep(.select-panel-custom .p-dropdown-item) {
  max-width: 100% !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  white-space: nowrap !important;
}

:deep(.select-custom .p-dropdown-label) {
  max-width: 100% !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  white-space: nowrap !important;
}

/* Contraindre la modal et ses éléments */
:deep(.p-dialog) {
  overflow: visible !important;
}

:deep(.p-dialog-content) {
  overflow: visible !important;
}

</style>

<style>
/* Contraindre l'overlay du sélecteur */
.p-select-overlay {
  max-width: calc(50vw - 4rem) !important;
  width: auto !important;
}

@media (max-width: 960px) {
  .p-select-overlay {
    max-width: calc(90vw - 4rem) !important;
  }
}
</style>

